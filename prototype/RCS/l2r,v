head	1.4;
access;
symbols;
locks
	drew:1.4; strict;
comment	@# @;


1.4
date	2001.08.09.19.32.11;	author drew;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.09.18.22.38;	author drew;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.08.20.24.25;	author drew;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.02.20.20.08;	author drew;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@#!/usr/bin/perl -w

use strict;

use Socket;
use IO::Socket::INET;

require "discover.pl";
require "broadcast.pl";
require "mac.pl";
require "route.pl";

print "l2r Startup.\n";

unless (-d '/etc/l2r') {
	mkdir('/etc/l2r', 755) or die;
}
open(PROC, "> /proc/sys/net/ipv4/ip_forward");
print PROC 1;
close PROC;
system('./route-clear | sh -x');

my($Serial) = 0;
my($Me);
my($Ip);
my($Pid);
my($Debug) = 1;

&load_serial();
&load_config();

my(%Packet);

my(%Route);
my(%Seen);

my($Sock) = new IO::Socket::INET(LocalPort => 2, Proto => 'udp')
	or die "socket: $@@";

&iamsend();
&run;

END {
	kill 9, $Pid if $Pid;
}

sub iamsend {
	my($i, $localport);

	my($host) = `hostname`;		chomp($host);
	my ($ip) = `hostname -i`;	chomp($ip);
	my ($mac) = mac_get_name();

	my($iam) = "iam $Me $mac $ip $host\n";
	if ($Pid = fork()) {
		return;
	}
	socket(Send, PF_INET, SOCK_DGRAM,getprotobyname("udp"));

	$localport = sockaddr_in(2, INADDR_LOOPBACK);
	for (;;) {
		broadcast($iam . 'path', ++$Serial, $Me);
		save_serial();
		for ($i=0; $i < 3; ++$i) {
			send(Send, "tick 1", 0, $localport);
			sleep(3);
		}
	}
}

1;

sub run {
	my($him, $datagram);

	while ($him = $Sock->recv($datagram, 1500, 0)) {
		$Ip = inet_ntoa(substr($him, 4, 4));
print "From: $Ip\n" if $Debug > 1;
		process($datagram);

		save_path();
	}
}

sub process {
	my($line);

	%Packet = ();

	foreach $line (split(/\n/, $_[0])) {
		&handle(split(' ', $line));
	}
}

# path
# iam
# auth
# ping
# ship
# dead

sub handle {
	my($cmd, @@arg) = @@_;

	return unless defined $cmd;
	return if $cmd eq '';

	if ($cmd eq 'broadcast') {
		my($ser) = shift (@@arg);

		return if $Seen{$ser}++;
		broadcast('broadcast', $ser, @@arg);
		&handle(@@arg);
		
		return;
	}

	if ($cmd eq 'on') {
		my($host) = shift (@@arg);
		my($ser) = shift (@@arg);

		return if $Seen{$ser}++;
		broadcast('on', $host, $ser, @@arg);

		&handle(@@arg) if $host eq $Me;
		
		return;
	}

	if ($cmd eq 'debug') {
		$Debug = shift (@@arg);
		return;
	}

	if ($cmd eq 'tick') {
		tick(@@arg);
		return;
	}

	$Packet{$cmd} = "@@arg" ;

	print "Got: $cmd @@arg\n" if $Debug > 1;

	if ($cmd eq 'restart') {
		save_serial();
		kill 15, $Pid;

		print "Restarting...";
		eval {
			exec $0;
		};
		print "Exec failed. $@@\n";
		return;
	}

	if ($cmd eq 'path') {
		&path(@@arg);
		return;
	}

	if ($cmd eq 'iam') {
		my($name, $mac, $ip, $host) = @@arg;
print "new-host-iam $name === $mac, $ip, $host\n" unless $Route{$name}{'ip'};
		$Route{$name}{'mac'} = $mac;
		$Route{$name}{'ip'} = $ip;
		$Route{$name}{'domain'} = $host;
		return;
	}

	if ($cmd eq 'ship') {
		print "Ship not impleted\n";
		return;
	}

	if ($cmd eq 'dead') {
		print "Dead not impleted\n";
		return;
	}

	if ($cmd eq 'ping') {
		print "Ping not impleted\n";
		return;
	}

	if ($cmd eq 'auth') {
		print "Auth not impleted\n";
		return;
	}

	if ($cmd eq 'date') {
		return;
	}

	print "Command '$cmd' unknown.\n";
}

#
# path SERIAL host last next ... first
#
sub path {
	my(@@arg) = @@_;
	my($ser) = shift @@arg;
	my($host) = shift @@arg;

	if ($host eq $Me) {
		print "path is me\n" if $Debug > 2;
		return;
	}

	if (defined $Route{$host}{'serial'}) {

		if ($ser <= $Route{$host}{'serial'}) {
			print "Seen ser $ser for $host = $Route{$host}{'serial'}\n" if $Debug > 2;
			return;
		}
	}

	$Route{$host}{'ttl'} = 10;
	$Route{$host}{'serial'} = $ser;

	unless (defined $Route{$host}{'path'}) {
		$Route{$host}{'via'} = $Ip;

		if (@@arg) {
			$Route{$host}{'path'} = "@@arg";
			my($ip) = $Route{$host}{'ip'};
			print "New route to $host ($ip) via $Ip (@@arg)\n";
			route_add($ip, $Ip);
		} else {
			$Route{$host}{'path'} = "";
			print "Direct route: $host\n";
		}
	} elsif ($Route{$host}{'via'} eq $Ip) {
		print "Bless $host the network didn't change.\n" if $Debug > 1;
	} else {
		my($ip) = $Route{$host}{'ip'};

		my($old) = $Route{$host}{'path'};
		print "Change route for $host ($ip) via $Ip (@@arg) was $old\n";
		route_del($ip);
		route_add($ip, $Ip);
		$Route{$host}{'via'} = $Ip;
		$Route{$host}{'path'} = "@@arg";
	}

	my($iam) = 'iam ' . $Packet{'iam'} . "\n";
	broadcast($iam . 'path', $ser, $host, @@arg, $Me);

	return;
}

sub tick {
	my($host, $ip);

	foreach $host (keys %Route) {
		next if ($host eq $Me);

		print "tick $host $Route{$host}{'ttl'}\n" if $Debug > 2;
		if ($Route{$host}{'ttl'}-- <= 0) {
			$ip = $Route{$host}{'ip'};
			print "He's dead jim: lost route: $host($ip)\n";
			route_del($ip);
			delete $Route{$host};
		}
	}
	print "----------------------------------------------\n" if $Debug > 2;
}

sub load_serial {
	unless (open(SERIAL, "< /etc/l2r/serial")) {
		$Serial = 1;
		return;
	}
	$Serial = <SERIAL>; chomp $Serial;
	close(SERIAL);
	print "Serial: $Serial\n";
}

sub save_serial {
	unless (open(SERIAL, "> /etc/l2r/serial")) {
		$Serial = 1;
		return;
	}
	print SERIAL $Serial, "\n";
	close SERIAL;
}

sub load_config {
	unless (open(CONFIG, "< /etc/l2r/config")) {
		$Me = mac_get_name();
		return;
	}
	while (<CONFIG>) {
		next if /^#/;
		next if /^\s+$/;

		chomp;
		if (/^name\s+(\S+)/) {
			$Me = $1;
			print "name $Me\n";
		}

		if (/^debug\s+(\S+)/) {
			$Debug = $1;
			print "debug $Debug\n";
		}
	}
	close(CONFIG);
}

sub save_config {
	unless (open(CONFIG, "> /etc/l2r/config")) {
		$Serial = 1;
		return;
	}
	print CONFIG $Serial, "\n";
	close CONFIG;
}

sub save_path {
	my($host, $ip, $ser, $path);

	open(PATH, "> /etc/l2r/paths");

	foreach $host (sort keys %Route) {
		$ip   = $Route{$host}{'ip'} || 'Fucked';
		$ser  = $Route{$host}{'serial'} || 'Fucked';
		$path = $Route{$host}{'path'} || 'Fucked';

		print PATH "$ser\t$ip\t$host $path\n";
	}
	close(PATH);
}
@


1.3
log
@*** empty log message ***
@
text
@d21 1
a34 4

my(%Ser);
my(%Path);
my(%Name);
d48 4
a51 3
	my($host) = `hostname`;
	chomp($host);
	my ($ip) = `hostname -i`;
a53 1
	chomp($ip);
d58 3
d64 3
a66 3
		for ($i=0; $i < 10; ++$i) {
			broadcast('drop', '1');
			sleep(1);
d71 2
d135 2
a136 2
	if ($cmd eq 'drop') {
		drop(@@arg);
d163 4
a166 2
print "$name -> $mac, $ip, $host\n" unless $Name{$name};
		$Name{$name} = [ $mac, $ip, $host ];
d210 1
a210 1
	if (defined $Ser{$host}) {
d212 2
a213 2
		if ($ser <= $Ser{$host}) {
			print "Seen ser $ser for $host = $Ser{$host}\n" if $Debug > 2;
d218 6
a223 2
	$Ser{$host} = $ser;
	unless (defined $Path{$host}) {
d225 3
a227 3
			$Path{$host} = "@@arg";
			my($ip) = $Name{$host}[1];
			print "New route via $Ip (@@arg) -> $host ($ip)\n";
d230 1
a230 1
			$Path{$host} = "";
d233 1
a233 1
	} elsif ($Path{$host} eq "@@arg") {
d236 8
a243 2
		print "The Pain. The pain. $Path{$host} -> @@arg\n";
		$Path{$host} = "@@arg";
d252 17
d321 1
a321 1
	my($host, $ip);
d326 3
a328 2
		$ip = $Name{$host}[1];
		$ser = $Route{host}{'serial'};
d330 1
a330 1
		print PATH "$ser\t$ip\t$host $Path{$host}\n";
@


1.2
log
@*** empty log message ***
@
text
@d11 1
d18 3
d32 3
d64 4
a67 1
		sleep(10);
d133 6
a138 1
	$Packet{$cmd} = [ @@arg ] ;
d155 1
a155 33
		my($ser) = shift @@arg;
		my($host) = shift @@arg;

		if ($host eq $Me) {
			print "path is me\n" if $Debug > 2;
			return;
		}

		if (defined $Ser{$host}) {

			if ($ser <= $Ser{$host}) {
				print "Seen ser $ser for $host = $Ser{$host}\n" if $Debug > 2;
				return;
			}
		}

		$Ser{$host} = $ser;
		unless (defined $Path{$host}) {
			if (@@arg) {
				$Path{$host} = "@@arg";
				print "New route via $Ip: $host = @@arg\n";
			} else {
				$Path{$host} = "";
				print "Direct route: $host\n";
			}
		} elsif ($Path{$host} eq "@@arg") {
			print "Bless $host the network didn't change.\n" if $Debug > 1;
		} else {
			print "The Pain. The pain. $Path{$host} -> @@arg\n";
			$Path{$host} = "@@arg";
		}

		broadcast('path', $ser, $host, @@arg, $Me);
d161 1
d193 45
d290 1
a290 1
	my($path);
d294 5
a298 2
	foreach $path (sort keys %Ser) {
		print PATH "$Ser{$path} $path $Path{$path}\n";
@


1.1
log
@Initial revision
@
text
@d1 3
a3 1
#!/usr/bin/perl
d9 2
d14 18
a31 1
my($Me) = `hostname`; chomp $Me;
d33 1
a33 1
$sock = new IO::Socket::INET(LocalPort => 2, Proto => 'udp')
d36 35
a70 4
discover();
while ($him = $sock->recv($datagram, 1500, 0)) {
	process($datagram);
	discover();
d74 4
d93 33
a125 1
	print "Got: $cmd @@arg\n";
d128 3
d132 5
a136 1
		exec $0;
d140 7
a146 2
		$ser = shift @@arg;
		$host = shift @@arg;
d151 1
a151 1
				print "Seen ser $ser for $host = $Ser{$host}\n";
a155 1

d157 14
a170 1
		$Path{$host} = "@@arg";
d177 2
d183 1
d188 1
d193 1
d198 1
d201 6
a206 1
	print "Not supported.\n";
d209 9
a217 2
sub broadcast {
	%Interface = discover();
d219 8
a226 2
	socket(Sock, PF_INET, SOCK_DGRAM,getprotobyname("udp"));
	setsockopt(Sock, SOL_SOCKET, SO_BROADCAST, 1);
d228 14
a241 2
	foreach $dev (sort keys %Interface) {
		$ip = inet_aton($Interface{$dev});
d243 7
a249 1
		$port = sockaddr_in(2, $ip);
d251 4
a254 2
		send(Sock, "@@_", 0, $port);
		print "sent $dev->$Interface{$dev}: @@ARGV\n";
d256 3
d260 9
a268 1
	print "Broadcast @@_\n";
@
