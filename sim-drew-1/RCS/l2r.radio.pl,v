head	1.2;
access;
symbols;
locks
	drew:1.2; strict;
comment	@# @;


1.2
date	2001.09.02.00.44.26;	author drew;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.31.16.23.52;	author drew;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@package Radio;

use strict;

# status F, M, B, S, A

#	transmit($radio, "I name status [master]");
#	transmit($radio, "M master slave");
#	transmit($radio, "B $name $from $master");
#	transmit($radio, "S slave master");
#	transmit($radio, "C frommaster tomaster slavesoffrom");

# external transmit($radio, $msg);

sub new {
	my($mac, $name, $width) = @@_; 

	my $radio = {
		mac   => $mac,
		name  => $name,
		width => $width,
	}; 
	bless $radio;
	
	$radio->{x} = int(rand($width));
	$radio->{y} = int(rand($width));

	$radio->{dx} = int(rand(20)) - 10;
	$radio->{dy} = int(rand(20)) - 10;

	$radio->{status} = 'F';
	$radio->{master} = '';
	$radio->{clock} = int(rand(1000));

	return $radio;
}

sub receive {
	my($radio, $from, $msg) = @@_;

	print "Receive  $from => $radio->{mac} msg: $msg\n";

	if ($radio->{mac} eq $from) {
		main::abort("I am not allowed to receive my own transmits");
		return;
	}

	$msg =~ /^. (\S+)/; 
	$radio->{arp}{$1} = $from;

	if ($msg =~ /^I (\S+) (\S+) (.*)/) {
		heard_iam($radio, $from, $1, $2, split(' ', $3));
		return;
	}

	if ($msg =~ /^M (\S+) (\S+)/) {
		heard_be_master($radio, $from, $1, $2);
		return;
	}

	if ($msg =~ /^S (\S+) (\S+)/) {
		heard_be_slave($radio, $from, $1, $2);
		return;
	}

	if ($msg =~ /^B (\S+) (\S+) (\S+)/) {
		heard_be_bond($radio, $from, $1, $2, $3);
		return;
	}

	if ($msg =~ /^F (\S+)/) {
		heard_be_free($radio, $from, $1);
		return;
	}

	if ($msg =~ /^A (\S+) (\S+)/) {
		heard_be_apprentice($radio, $from, $1, $2);
		return;
	}

	if ($msg =~ /^C (\S+) (\S+) (\S+)/) {
		heard_count_request($radio, $1, $2, $3);
		return;
	}
	main::abort("Unknown message $msg");
}

sub tick {
	my($radio) = @@_;

	$radio->{clock} = 1000;
	clean_tables($radio);

	if ($radio->{status} eq 'S' || $radio->{status} eq 'B') {
		unless ($radio->{arp}{$radio->{master}}) {
			print "I $radio->{name} am free from $radio->{master}\n";
			$radio->{master} = '';
			$radio->{status} = 'F';
		}
	}

	if ($radio->{status} eq 'M') {
		$radio->{status} = 'F' unless have_slaves($radio);
	}

		
	if ($radio->{status} eq 'S') {
		return if $radio->{ping}-- > 0;

		$radio->{ping} = 10;
	}

	my($masters) = list_masters($radio);

	transmit($radio, "I $radio->{name} $radio->{status} $masters");
}

sub list_masters {
	my($radio) = @@_;

	my($master) = $radio->{master};
	
	return join(' ', $master, grep !/^$master$/, keys %{ $radio->{masters} });
}

sub clean_tables {
	my($radio) = @@_;
	my($name) = $radio->{name};
	my($key, $other, $link, $mac, $cnt);

	foreach $key (qw(bond link)) {
		$cnt = 0;
		foreach $other (keys %{ $radio->{$key} }) {
			$link = $radio->{$key}{$other};
			$mac = $radio->{arp}{$link};

			++$cnt, next if defined $mac && inrange($radio, $mac);

			print "Lost $key connection from $name to $other\n";
			delete $radio->{$key}{$other};
		}
		delete $radio->{$key} unless $cnt;
	}

	foreach $key (qw(bond link masters slaves arp)) {
		$cnt = 0;
		foreach $other (keys %{ $radio->{$key} }) {
			$mac = $radio->{arp}{$other};

			++$cnt, next if defined $mac && inrange($radio, $mac);

			print "Lost $key connection from $name to $other\n";
			delete $radio->{$key}{$other};
		}
		delete $radio->{$key} unless $cnt;
	}

}

sub heard_iam {
	my($radio, $mac, $from, $status, $master, @@masters) = @@_;

	my($name)  = $radio->{name};
	my($iam)   = $radio->{status};

	if ($iam eq 'F' || $iam eq 'A') {
		if ($status eq 'M' or $status eq 'F' or $status eq 'A') {
			transmit($radio, "M $name $from");
			return;
		}

		if ($status eq 'S' || $status eq 'B') {
			return;
		}

		main::abort("Iam $name heard unknown status $status");
		return;
	}

	if ($iam eq 'S' || $iam eq 'B') {
		if ($status eq 'F' or $status eq 'A') {
			transmit($radio, "A $name $from");
			return;
		}

		if ($status eq 'S' || $status eq 'B') {
			build_links($radio, $from, $master, @@masters);
			return;
		}

		if ($status eq 'M') {
			build_links($radio, $name, $master, @@masters);
			return;
		}
	}

	if ($iam eq 'M') {
		if ($status eq 'F' or $status eq 'A') {
			make_slave($radio, $from);
			return;
		}

		if ($status eq 'S' or $status eq 'B') {
			build_bonds($radio, $from, $master, @@masters);
			return;
		}

		if ($status eq 'M') {
			my($slaves) = have_slaves();
			transmit($radio, "C $name $from $slaves");
			return;
		}
	}

	main::abort("Don't know how to map iam $iam heard $status message");
}

sub build_bonds {
	my($radio, $slave, @@masters) = @@_;
	my($master);
	my($name) = $radio->{name};

	foreach $master (@@masters) {
		next unless defined $master and $master;
		next if $master eq $name;	# its me

		next if defined $radio->{link}{$master};

		print "Build new bond to $name => $slave => $master\n";

		$radio->{link}{$master} = $slave;
		transmit($radio, "B $name $slave $master");
	}
}

sub build_links {
	my($radio, $slave, @@masters) = @@_;
	my($master);
	my($name) = $radio->{name};
	my($mymaster) = $radio->{master};

	foreach $master (@@masters) {
		next unless defined $master and $master;
		next if $master eq $mymaster;	# its to my master

		next if defined $radio->{link}{$master};

		print "Maybe link $mymaster => $slave => $name => $master\n";

		$radio->{link}{$master} = $slave;
#		transmit($radio, "L $mymaster $slave $name $master");
	}
}

sub heard_be_master {
	my($radio, $mac, $from_slave, $to_master) = @@_;

	my($name) = $radio->{name};

	# message not for me
	if ($name ne $to_master) {
		if ($radio->{status} eq 'F') {
#			transmit($radio, "M $name $to_master");
			return;
		}
			
		return;
	}

	print "Me ($name) got slave: $mac $from_slave\n";

	$radio->{status} = 'M';
	make_slave($radio, $from_slave);
}

sub heard_be_slave {
	my($radio, $mac, $from_master, $to_slave) = @@_;

	$radio->{masters}{$from_master} = 1;

	my($name) = $radio->{name};

	# message not for me
	if ($name ne $to_slave) {
		if ($radio->{status} eq 'F') {
			transmit($radio, "M $name $from_master");
		}
		return;
	}

	if ($radio->{status} eq 'M') {
		print "Me ($name) now forced slave of? $mac $from_master\n";
		main::dump_all('Simulation.Force');

#		$radio->{status} = 'S';
#		$radio->{master} = $from_master;
#		transmit($radio, "F $name");
		return;
	}

	print "Me ($name) now slave of: $from_master\n";

	$radio->{status} = 'S';
	$radio->{master} = $from_master;
	$radio->{clock} = 1000;
}

sub heard_be_bond {
	my($radio, $mac, $from, $me, $to) = @@_;

	my($name) = $radio->{name};

	print "bond? me=$name,  $from -> $me -> $to\n";

	# message not for me
	return if $name ne $me;

	if ($from eq $radio->{master}) {
		print "bond? my master asked me to bond\n";
	} else {
		print "bond? bonding for other master\n";
	}

	print "Me ($me) bond for $from and $to\n";

	$radio->{status} = 'B';
	$radio->{bond}{$to} = $from;
	$radio->{master} ||= $from;
}

sub heard_be_free {
	my($radio, $mac, $master) = @@_;

	if ($radio->{master} ne $master) {
		return;
	}

	print "Me ($radio->{name}) has been freed from $master\n";

	$radio->{status} = 'F';
	$radio->{master} = '';

	transmit($radio, "I $radio->{name} $radio->{status} $radio->{master}");
}

sub heard_be_apprentice {
	my($radio, $mac, $from_slave, $to_freeman) = @@_;

	return if $radio->{name} ne $to_freeman;

	$radio->{status} = 'A' if $radio->{status} eq 'F';
	$radio->{status} = 'M' if $radio->{status} eq 'A' && $radio->{help}++ > 5;
	transmit($radio, "I $radio->{name} $radio->{status} ");
}

sub heard_count_request {
	my($radio, $from_master, $to_master, $slave_count) = @@_;

	my($name) = $radio->{name};
	my($nslaves) = $radio->have_slaves();

	# message not for me
	return if $name ne $to_master;

	if ($slave_count < $nslaves) {
print "Won count me=$name has $nslaves, he $from_master has $slave_count\n";
		transmit($radio, "C $name $from_master $nslaves");
	} else {
print "Lost count me=$name has $nslaves, he $from_master has $slave_count\n";
		$radio->{status} = 'F';
		transmit($radio, "F $name");
		transmit($radio, "M $name $from_master");
	}
}

sub have_slaves {
	my($radio) = @@_;
	my($slave);
	my($nslaves) = 0;

	foreach $slave (keys %{ $radio->{slaves} }) {
		++$nslaves;
	}
	$radio->{nslaves} = $nslaves;
	return $nslaves;
}


sub make_slave {
	my($radio, $slave) = @@_;

	my($name) = $radio->{name};

	$radio->{slaves}{$slave} = 10_000;
	transmit($radio, "S $name $slave");
}

# external transmit($radio, $msg);
1;
@


1.1
log
@Initial revision
@
text
@d11 1
d48 5
a52 6
	if ($msg =~ /^I (\S+) (\S+) (\S+)/) {
		heard_iam($radio, $from, $1, $2, $3);
		return;
	}
	if ($msg =~ /^I (\S+) (\S+)/) {
		heard_iam($radio, $from, $1, $2, '');
d75 10
d91 16
d108 33
a140 4
		if (--$radio->{ttl} <= 0) {
			$radio->{ttl} = 10;
			transmit($radio, "I $radio->{name} $radio->{status} $radio->{master}");
			return;
d142 2
a143 1
		return if (--$radio->{master_ttl});
d145 4
a148 1
		return if inrange($radio, $radio->{master});
d150 6
a155 2
		$radio->{master} = '';
		$radio->{status} = 'F';
d157 1
a157 1
	transmit($radio, "I $radio->{name} $radio->{status} $radio->{master}");
d161 1
a161 1
	my($radio, $mac, $from, $status, $master) = @@_;
d166 2
a167 2
	if ($iam eq 'F') {
		if ($status eq 'M' or $status eq 'F') {
a172 2
			$radio->{status} = 'M';
			transmit($radio, "B $name $from $master");
d176 1
d180 3
a182 3
	if ($iam eq 'S') {
		if ($radio->{master} eq $from) {
			$radio->{master_ttl} = 10;
d186 2
a187 8
		return;
	}

	if ($iam eq 'B') {
		if ($status eq 'F') {
			return;
		}
		if ($status eq 'S') {
d190 1
d192 1
d198 2
a199 6
		if ($status eq 'F') {
			if ($master eq $name) {
				$radio->{slaves}{$from}{ttl} = 1000;
			}

			transmit($radio, "S $name $from");
d203 2
a204 12
		if ($status eq 'S') {
print "???? radio=$radio, status=$status, master=$master, name=$name, from=$from.\n";
			if ($master eq $name) {
			#	$radio->{'slaves'}{$from} = {
			#		'ttl' => 1000,
			#		'mac' => $mac,
			#	};
				return;
			}

			print "Building a bond $name -> $from -> $master\n";
			transmit($radio, "B $name $from $master");
a207 6
		if ($status eq 'B') {
			print "Return a bond $name -> $from -> $master\n";
			transmit($radio, "B $name $from $master");
			return;
		}
				
d209 2
a210 3
			$radio->{status} = 'F';
			transmit($radio, "F $name");
			transmit($radio, "M $name $from");
d218 37
d256 1
a256 1
	my($radio, $mac, $from, $who) = @@_;
d261 8
a268 1
	return if $name ne $who;
d270 1
a270 1
	print "Me ($name) got slave: $mac $from\n";
d273 1
a273 6
	$radio->{slaves}++;
	$radio->{slave}{$from}{master} = $name;
	$radio->{slave}{$from}{master_mac} = $mac;
	$radio->{slave}{$from}{ttl}    = 10;

	transmit($radio, "S $name $from");
d277 3
a279 1
	my($radio, $mac, $from, $who) = @@_;
d284 16
a299 1
	return if $name ne $who;
d301 1
a301 1
	print "Me ($name) now slave of: $mac $from\n";
d304 2
a305 2
	$radio->{master} = $from;
	$radio->{master_mac} = $mac;
d313 2
a314 1
print "bond? me=$name,  $from -> $me -> $to\n";
d318 6
d328 1
a341 1
	$radio->{master_mac} = '';
d346 31
a376 1
sub check_range_slaves {
d379 1
d381 2
a382 4
	foreach $slave (keys %{$radio->{slave}}) {
		if (inrange($radio, $slave)) {
			next;
		}
d384 2
a387 2
sub check_range_master {
	my($radio);
d389 7
a395 6
	if (inrange($radio, $radio->{master_mac})) { 
		return;
	}
	$radio->{master} = '';
	$radio->{master_mac} = '';
	$radio->{status} = 'F';
@
